set nocompatible               " be iMproved

"--------------------------------------------------------------------------
" neobundle

filetype off                   " Required!

if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#begin(expand('~/.vim/bundle/'))

filetype plugin indent on     " Required!

" Installation check.
if neobundle#exists_not_installed_bundles()
  echomsg 'Not installed bundles : ' .
        \ string(neobundle#get_not_installed_bundle_names())
  echomsg 'Please execute ":NeoBundleInstall" command.'
  "finish
endif

" plugins..
NeoBundle 'Shougo/neobundle.vim'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/vimfiler.vim'
NeoBundle 'Shougo/vimshell.vim'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'Shougo/neocomplcache'

call neobundle#end()

filetype plugin on

set number
set ignorecase
set smartcase
set autoindent
set showmatch
set autoread
set hlsearch
nmap <Esc><Esc> :nohlsearch<CR><Esc> "

set incsearch
set statusline=[%L]\ %t\ %y%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}%r%m%=%c:%l/%L
set laststatus=2 " show status line always
set ruler

" coomand line mode
set wildmenu
set wildmode=longest:full,full

set tags=tags

"==============================================================================
" unite.vim
"==============================================================================
let g:unite_enable_start_insert = 1
let g:unite_source_file_mru_time_format = ""
let g:unite_source_file_mru_limit = 500
nmap <C-l> :Unite buffer file_mru<CR>
noremap <C-P> :Unite buffer<CR>
noremap <C-N> :Unite -buffer-name=file file<CR>

" sourcesを「今開いているファイルのディレクトリ」とする
noremap :uff :<C-u>UniteWithBufferDir file -buffer-name=file<CR>

" ウィンドウを分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
" ウィンドウを縦に分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')

" Unite バッファで <Esc>x2 で終了
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>

"==============================================================================
"" unite-outline.vim
"==============================================================================
nmap <C-o> :Unite outline<CR>

"==============================================================================
"" VimFIler
"==============================================================================
nmap <C-x> :VimFiler<CR>
let g:vimfiler_as_default_explorer = 1
"autocmd VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
"
"==============================================================================
"" NERDTree
"==============================================================================
nnoremap <silent><C-e> :NERDTreeToggle<CR>

" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" _(アンダーバー)区切りの補完を有効化
let g:neocomplcache_enable_underbar_completion = 1

" 補完候補の一番先頭を選択状態にする(AutoComplPopと似た動作)
let g:neocomplcache_enable_auto_select = 1

"ポップアップメニューで表示される候補の数。初期値は100
let g:neocomplcache_max_list = 20

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : ''
    \ }

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()

" 補完候補が出ていたら確定、なければ改行
inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "<CR>"

"==============================================================================
"" light-line
"==============================================================================

let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ }

syntax on

" if exists('&ambiwidth')
"   set ambiwidth=double
" endif

" encoding
" set encoding=euc-jp
" set fileencoding=japan
" set fileencodings=euc-jp,cp932,sjis,utf-8

set list
"set listchars=tab:^\ ,trail:\ ,extends:>,precedes:<,nbsp:%,eol:\
set listchars=tab:^\ ,trail:\ ,eol:\ 

set encoding=utf-8

""""""""""""""""""""""""""""""""""""""""
" html用の文字コード
function! s:html()
  set encoding=utf-8
  " set fileencodings=cp932,utf-8
  set fileencodings=utf-8
endfunction

" 文字コードの自動認識
function! s:pm()
  if &encoding !=# 'utf-8'
    set encoding=japan
    set fileencoding=japan
  endif
  if has('iconv')
    let s:enc_euc = 'euc-jp'
    let s:enc_jis = 'iso-2022-jp'
    " iconvがeucJP-msに対応しているかをチェック
    if iconv("\x87\x64\x87\x6a", 'cp932', 'eucjp-ms') ==# "\xad\xc5\xad\xcb"
      let s:enc_euc = 'eucjp-ms'
      let s:enc_jis = 'iso-2022-jp-3'
    " iconvがJISX0213に対応しているかをチェック
    elseif iconv("\x87\x64\x87\x6a", 'cp932', 'euc-jisx0213') ==# "\xad\xc5\xad\xcb"
      let s:enc_euc = 'euc-jisx0213'
      let s:enc_jis = 'iso-2022-jp-3'
    endif
    " fileencodingsを構築
    if &encoding ==# 'utf-8'
      let s:fileencodings_default = &fileencodings
      let &fileencodings = s:enc_jis .','. s:enc_euc .',cp932'
      let &fileencodings = &fileencodings .','. s:fileencodings_default
      unlet s:fileencodings_default
    else
      let &fileencodings = &fileencodings .','. s:enc_jis
      set fileencodings+=utf-8,ucs-2le,ucs-2
      if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
        set fileencodings+=cp932
        set fileencodings-=euc-jp
        set fileencodings-=euc-jisx0213
        set fileencodings-=eucjp-ms
        let &encoding = s:enc_euc
        let &fileencoding = s:enc_euc
      else
        let &fileencodings = &fileencodings .','. s:enc_euc
      endif
    endif
    " 定数を処分
    unlet s:enc_euc
    unlet s:enc_jis
  endif

  " 日本語を含まない場合は fileencoding に encoding を使うようにする
  if has('autocmd')
    function! AU_ReCheck_FENC()
      if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0
        let &fileencoding=&encoding
      endif
    endfunction
    autocmd BufReadPost * call AU_ReCheck_FENC()
  endif
endfunction

" ファイルのsuffixで文字コードの判断をすす
let suffix=expand("%:e")
if (match(suffix, 'html\|sub\|tx\|pig') == 0)
  call s:html()
else
 "call s:pm()
 call s:html()
endif

" 改行コードの自動認識
set fileformats=unix,dos,mac

" □とか○の文字があってもカーソル位置がずれないようにする
if exists('&ambiwidth')
  set ambiwidth=double
endif
""""""""""""""""""""""""""""""""""""""""

" coloring
set background=light
:colorscheme darkblue

"highlight SpecialKey guibg=#222222 cterm=underline ctermfg=darkgrey
"highlight Comment ctermfg=blue
highlight SpecialKey cterm=underline ctermfg=gray
highlight LineNr ctermfg=blue
highlight NonText ctermfg=darkgrey

" Key mapping
" nmap <C-L> :Tlist <CR>

" Ctrl+Nで次のバッファを表示、Ctrl+Pで前のバッファを表示
"map <C-N> :bnext<CR>
"map <C-P> :bprevious<CR>

" reload config file
nmap ,R :source ~/.vimrc<CR>

"map <C-P> <ESC>iif ($_::TEST_MODE) {use MLog;use Data::Dumper;MLog::write("$_::LOG_DIR/gundam_debug.arizuka", Dumper()); };<ESC>5hi

""""""""""""""""""""""""""""""""""""""""
" ファイルを開いた時に、以前のカーソル位置を復元する

function! s:RestoreCursorPostion()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup vimrc_restore_cursor_position
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()

" tab を多少使いやすく
" 一例
"nnoremap <silent> <leader>tf :<c-u>tabfirst<cr>
"nnoremap <silent> <leader>tl :<c-u>tablast<cr>
"nnoremap <silent> <leader>tn :<c-u>tabnext<cr>
"nnoremap <silent> <leader>tN :<c-u>tabNext<cr>
"nnoremap <silent> <leader>tp :<c-u>tabprevious<cr>
"nnoremap <silent> <leader>te :<c-u>tabedit<cr>
"nnoremap <silent> <leader>tc :<c-u>tabclose<cr>
"nnoremap <silent> <leader>to :<c-u>tabonly<cr>
"nnoremap <silent> <leader>ts :<c-u>tabs<cr>


set tabstop=4
set autoindent
set expandtab
set shiftwidth=4

" augroupを指定することで一括解除ができる
augroup vimrc
autocmd! FileType perl setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType php  setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType sh   setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType html setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd! FileType css  setlocal shiftwidth=4 tabstop=2 softtabstop=2
augroup END

" vim syntax
augroup filetypedetect
  au BufNewFile,BufRead *.pig set filetype=pig syntax=pig
augroup END

""""""""""""""
" compile perl file
" map cp :!perl -c %<CR>
func! CompilePerl()
  exec "!perl -c -Mwarnings %"
endfunc
map <leader>cp :call CompilePerl()<CR>
map <leader>res :!sudo apachectl restart<CR>

" compile check pig
nnoremap <C-c> :! /usr/bin/pig-0.11.0 -c %<Enter>

" cd dir of curr file automaticaly.
au  BufEnter * execute ":lcd " . expand("%:p:h")

" emacs like key bind in command line mode
" Ctrl+Aで行頭へ移動
:cnoremap <C-A>   <Home>
" Ctrl+Bで一文字戻る
:cnoremap <C-B>   <Left>
" Ctrl+Dでカーソルの下の文字を削除
:cnoremap <C-D>   <Del>
" Ctrl+Eで行末へ移動
:cnoremap <C-E>   <End>
" Ctrl+Fで一文字進む
:cnoremap <C-F>   <Right>
" Ctrl+Nでコマンドライン履歴を一つ進む
:cnoremap <C-N>   <Down>
" Ctrl+Pでコマンドライン履歴を一つ戻る
:cnoremap <C-P>   <Up>
" Alt+Ctrl+Bで前の単語へ移動
:cnoremap <Esc><C-B>  <S-Left>
" Alt+Ctrl+Fで次の単語へ移動
:cnoremap <Esc><C-F>  <S-Right>

" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
function! s:my_tabline()  "{{{
  let s = ''
  for i in range(1, tabpagenr('$'))
    let bufnrs = tabpagebuflist(i)
    let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
    let no = i  " display 0-origin tabpagenr.
    let mod = getbufvar(bufnr, '&modified') ? '!' : ' '
    let title = fnamemodify(bufname(bufnr), ':t')
    let title = '[' . title . ']'
    let s .= '%'.i.'T'
    let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
    let s .= no . ':' . title
    let s .= mod
    let s .= '%#TabLineFill# '
  endfor
  let s .= '%#TabLineFill#%T%=%#TabLine#'
  return s
endfunction "}}}
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示

" The prefix key.
nnoremap    [Tag]   <Nop>
nmap    t [Tag]
" Tab jump
for n in range(1, 9)
  execute 'nnoremap <silent> [Tag]'.n  ':<C-u>tabnext'.n.'<CR>'
endfor
" t1 で1番左のタブ、t2 で1番左から2番目のタブにジャンプ

map <silent> [Tag]c :tablast <bar> tabnew<CR>
" tc 新しいタブを一番右に作る
map <silent> [Tag]x :tabclose<CR>
" tx タブを閉じる
map <silent> [Tag]n :tabnext<CR>
" tn 次のタブ
map <silent> [Tag]p :tabprevious<CR>
" tp 前のタブ
