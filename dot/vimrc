set nocompatible               " be iMproved

"==============================================================================
" Neobundle

filetype off                   " Required!

if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#begin(expand('~/.vim/bundle/'))

filetype plugin indent on     " Required!

" Installation check.
if neobundle#exists_not_installed_bundles()
  echomsg 'Not installed bundles : ' .
        \ string(neobundle#get_not_installed_bundle_names())
  echomsg 'Please execute ":NeoBundleInstall" command.'
  "finish
endif

" plugins..
NeoBundle 'Shougo/neobundle.vim'
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/vimfiler.vim'
NeoBundle 'Shougo/vimshell.vim'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'itchyny/lightline.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'scrooloose/nerdtree'

NeoBundle 'Shougo/neocomplcache'
NeoBundle 'kien/ctrlp.vim'
NeoBundle 'tpope/vim-surround'
NeoBundle "tyru/caw.vim"
NeoBundle "PDV--phpDocumentor-for-Vim"

call neobundle#end()

filetype plugin on

set number
set ignorecase
set smartcase
set autoindent
set smartindent
set showmatch
set autoread
set incsearch
set foldmethod=marker
set ignorecase

set hlsearch
nmap <Esc><Esc> :nohlsearch<CR><Esc> "

" tag
set tags=/home/m.arizuka/htdocs/.tags
"==============================================================================
"" Encoding
"==============================================================================

" set encoding=euc-jp
" set fileencoding=japan
" set fileencodings=euc-jp,cp932,sjis,utf-8

set list
"set listchars=tab:^\ ,trail:\ ,extends:>,precedes:<,nbsp:%,eol:\
set listchars=tab:^\ ,trail:\ ,eol:\ 

set encoding=utf-8

" 改行コードの自動認識
set fileformats=unix,dos,mac

" □とか○の文字があってもカーソル位置がずれないようにする
if exists('&ambiwidth')
  set ambiwidth=double
endif

"==============================================================================
"" Status bar
"==============================================================================
set statusline=[%L]\ %t\ %y%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}%r%m%=%c:%l/%L
set laststatus=2 " show status line always
set ruler
set cmdheight=1
set title
set linespace=0
set wildmenu
set showcmd
""set textwidth=78
"set columns=100
""set lines=150
" バッファタブにパスを省略してファイル名のみ表示する
let g:buftabs_only_basename=1
" " バッファタブをステータスライン内に表示する
let g:buftabs_in_statusline=1
" " 現在のバッファをハイライト
let g:buftabs_active_highlight_group="Visual"
" " No paren match
" let loaded_matchparen = 1
"

" coomand line mode
set wildmode=longest:full,full

set tags=tags

" vimdiffの色設定
highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=22
highlight DiffDelete cterm=bold ctermfg=10 ctermbg=52
highlight DiffChange cterm=bold ctermfg=10 ctermbg=17
highlight DiffText   cterm=bold ctermfg=10 ctermbg=21

"==============================================================================
"" Unite.vim
"==============================================================================
let g:unite_enable_start_insert = 1
let g:unite_source_file_mru_time_format = ""
let g:unite_source_file_mru_limit = 500

" バッファ一覧
noremap <C-l><C-B> :Unite buffer<CR>
" ファイル一覧
noremap <C-l><C-F> :UniteWithBufferDir -buffer-name=files file<CR>
" 最近使ったファイルの一覧
noremap <C-l><C-R> :Unite file_mru<CR>
" レジスタ一覧
noremap <C-l><C-Y> :Unite -buffer-name=register register<CR>
" ファイルとバッファ
noremap <C-l><C-U> :Unite buffer file_mru<CR>
" 全部
noremap <C-l><C-A> :UniteWithBufferDir -buffer-name=files buffer file_mru bookmark file<CR>
" ESCキーを2回押すと終了する
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>
" Unite-grep
nnoremap <silent> ,ug :Unite grep:%:-iHRn<CR>

" sourcesを「今開いているファイルのディレクトリ」とする
noremap :uff :<C-u>UniteWithBufferDir file -buffer-name=file<CR>

" ウィンドウを分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
au FileType unite inoremap <silent> <buffer> <expr> <C-J> unite#do_action('split')
" ウィンドウを縦に分割して開く
au FileType unite nnoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')
au FileType unite inoremap <silent> <buffer> <expr> <C-K> unite#do_action('vsplit')

" Unite バッファで <Esc>x2 で終了
au FileType unite nnoremap <silent> <buffer> <ESC><ESC> :q<CR>
au FileType unite inoremap <silent> <buffer> <ESC><ESC> <ESC>:q<CR>

"==============================================================================
"" Unite-outline.vim
"==============================================================================
nmap <C-l><C-o> :Unite outline<CR>

"==============================================================================
"" VimFIler
"==============================================================================

" nmap <C-x> :VimFiler<CR>
let g:vimfiler_as_default_explorer = 1
"autocmd VimEnter * VimFiler -split -simple -winwidth=30 -no-quit
"
"==============================================================================
"" NERDTree
"==============================================================================

nnoremap <silent><C-e> :NERDTreeToggle<CR>
noremap <C-k><C-r> :NERDTreeFind<CR>

"==============================================================================
"" Caw
"==============================================================================

"\cでcomment toggle
nmap <Leader>c <Plug>(caw:i:toggle)
vmap <Leader>c <Plug>(caw:i:toggle)

"==============================================================================
"" Phpdoc
"==============================================================================

inoremap <C-k><C-c> <ESC>:call PhpDocSingle()<CR>i
nnoremap <C-k><C-c> :call PhpDocSingle()<CR>
vnoremap <C-k><C-c> :call PhpDocRange()<CR>

"==============================================================================
"" Neocomplcache 
"==============================================================================

" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 2
" Use smartcase.
let g:neocomplcache_enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplcache_min_syntax_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" _(アンダーバー)区切りの補完を有効化
let g:neocomplcache_enable_underbar_completion = 1

" 補完候補の一番先頭を選択状態にする(AutoComplPopと似た動作)
let g:neocomplcache_enable_auto_select = 1

"ポップアップメニューで表示される候補の数。初期値は100
let g:neocomplcache_max_list = 20

" Define dictionary.
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'default' : ''
    \ }

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplcache#undo_completion()
inoremap <expr><C-l>     neocomplcache#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplcache#smart_close_popup() . "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplcache#close_popup()
inoremap <expr><C-e>  neocomplcache#cancel_popup()

" 補完候補が出ていたら確定、なければ改行
inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "<CR>"

"==============================================================================
"" Unite history yank
"==============================================================================

let g:unite_source_history_yank_enable =1  "history/yankの有効化
noremap <C-k><C-y> :<C-u>Unite history/yank<CR>

"==============================================================================
"" Light-line
"==============================================================================

let g:lightline = {
      \ 'colorscheme': 'wombat',
      \ }

syntax on

" coloring
set background=light
:colorscheme nord

highlight SpecialKey cterm=underline ctermfg=gray
highlight LineNr ctermfg=blue
highlight NonText ctermfg=darkgrey

"==============================================================================
"" Ctrlp
"==============================================================================

set runtimepath^=~/.vim/bundle/ctrlp.vim
" let g:ctrlp_max_height          = &lines " 目一杯に一覧
let g:ctrlp_max_height          = 10 " 10行
let g:ctrlp_jump_to_buffer      = 2 " タブで開かれていた場合はそのタブに切り替える
let g:ctrlp_clear_cache_on_exit = 1 " 終了時キャッシュをクリアする
let g:ctrlp_mruf_max            = 500 " MRUの最大記録数
"let g:ctrlp_highlight_match     = [1, 'IncSearch'] "絞り込みで一致した部分のハイライト
let g:ctrlp_open_new_file       = 1 " 新規ファイル作成時にタブで開く
let g:ctrlp_open_multi          = '10t' " 複数ファイルを開く時にタブで最大10まで開く
let g:ctrlp_match_window_reversed = 0 " Change the listing order of the files in the match window.
let g:ctrlp_mruf_default_order = 0 " Set this to 1 to disable sorting when searching in MRU mode:
let g:ctrlp_map = '<c-a>' " Start CtrlP by Ctrl-k :p
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_prompt_mappings = {
  \ 'PrtBS()':              ['<c-h>', '<bs>', '<c-]>'],
  \ 'PrtDelete()':          ['<del>'],
  \ 'PrtDeleteWord()':      ['<c-w>'],
  \ 'PrtClear()':           ['<c-u>'],
  \ 'PrtSelectMove("j")':   ['<c-n>', '<c-j>', '<down>'],
  \ 'PrtSelectMove("k")':   ['<c-p>', '<c-k>', '<up>'],
  \ 'PrtHistory(-1)':       [],
  \ 'PrtHistory(1)':        [],
  \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
  \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
  \ 'AcceptSelection("t")': ['<c-t>', '<MiddleMouse>'],
  \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
  \ 'ToggleFocus()':        ['<s-tab>'],
  \ 'ToggleRegex()':        ['<c-r>'],
  \ 'ToggleByFname()':      ['<c-d>'],
  \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
  \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
  \ 'PrtExpandDir()':       ['<tab>'],
  \ 'PrtInsert("w")':       ['<F2>', '<insert>'],
  \ 'PrtInsert("s")':       ['<F3>'],
  \ 'PrtInsert("v")':       ['<F4>'],
  \ 'PrtInsert("+")':       ['<F6>'],
  \ 'PrtCurStart()':        ['<c-a>'],
  \ 'PrtCurEnd()':          ['<c-e>'],
  \ 'PrtCurLeft()':         ['<left>', '<c-^>'],
  \ 'PrtCurRight()':        ['<c-l>', '<right>'],
  \ 'PrtClearCache()':      ['<F5>'],
  \ 'PrtDeleteMRU()':       ['<F7>'],
  \ 'CreateNewFile()':      ['<c-y>'],
  \ 'MarkToOpen()':         ['<c-z>'],
  \ 'OpenMulti()':          ['<c-o>'],
  \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
  \ }

"==============================================================================
" Keyboard shortcuts
"==============================================================================

" Ctrl+Nで次のバッファを表示、Ctrl+Pで前のバッファを表示
map <C-N> :bnext<CR>
map <C-P> :bprevious<CR>

" reload config file
nmap ,R :source ~/.vimrc<CR>

" 対応する括弧に移動
nnoremap ( %
nnoremap ) %

" compile check pig
" nnoremap <C-c> :! /usr/bin/pig-0.11.0 -c %<Enter>

"map <C-P> <ESC>iif ($_::TEST_MODE) {use MLog;use Data::Dumper;MLog::write("$_::LOG_DIR/gundam_debug.arizuka", Dumper()); };<ESC>5hi

"==============================================================================
"" Restore cursol position
"==============================================================================

" ファイルを開いた時に、以前のカーソル位置を復元する
function! s:RestoreCursorPostion()
  if line("'\"") <= line("$")
    normal! g`"
    return 1
  endif
endfunction

augroup vimrc_restore_cursor_position
  autocmd!
  autocmd BufWinEnter * call s:RestoreCursorPostion()


"==============================================================================
"" Syntax setting
"==============================================================================
set tabstop=4
set autoindent
set expandtab
set shiftwidth=4

" augroupを指定することで一括解除ができる
augroup vimrc
autocmd! FileType perl setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType php  setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType sh   setlocal shiftwidth=4 tabstop=4 softtabstop=4 expandtab
autocmd! FileType html setlocal shiftwidth=2 tabstop=2 softtabstop=2 expandtab
autocmd! FileType css  setlocal shiftwidth=4 tabstop=2 softtabstop=2
augroup END

" vim syntax
augroup filetypedetect
  au BufNewFile,BufRead *.pig set filetype=pig syntax=pig
augroup END

"==============================================================================
" cd dir of curr file automaticaly.
"==============================================================================
au  BufEnter * execute ":lcd " . expand("%:p:h")

"==============================================================================
" Emacs like key bind in command line mode
"==============================================================================

" Ctrl+Aで行頭へ移動
:cnoremap <C-A>   <Home>
" Ctrl+Bで一文字戻る
:cnoremap <C-B>   <Left>
" Ctrl+Dでカーソルの下の文字を削除
:cnoremap <C-D>   <Del>
" Ctrl+Eで行末へ移動
:cnoremap <C-E>   <End>
" Ctrl+Fで一文字進む
:cnoremap <C-F>   <Right>
" Ctrl+Nでコマンドライン履歴を一つ進む
:cnoremap <C-N>   <Down>
" Ctrl+Pでコマンドライン履歴を一つ戻る
:cnoremap <C-P>   <Up>
" Alt+Ctrl+Bで前の単語へ移動
:cnoremap <Esc><C-B>  <S-Left>
" Alt+Ctrl+Fで次の単語へ移動
:cnoremap <Esc><C-F>  <S-Right>

" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

"==============================================================================
" Tab
"==============================================================================

" Set tabline.
function! s:my_tabline()  "{{{
  let s = ''
  for i in range(1, tabpagenr('$'))
    let bufnrs = tabpagebuflist(i)
    let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
    let no = i  " display 0-origin tabpagenr.
    let mod = getbufvar(bufnr, '&modified') ? '!' : ' '
    let title = fnamemodify(bufname(bufnr), ':t')
    let title = '[' . title . ']'
    let s .= '%'.i.'T'
    let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
    let s .= no . ':' . title
    let s .= mod
    let s .= '%#TabLineFill# '
  endfor
  let s .= '%#TabLineFill#%T%=%#TabLine#'
  return s
endfunction "}}}
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示

" The prefix key.
nnoremap    [Tag]   <Nop>
nmap    t [Tag]
" Tab jump
for n in range(1, 9)
  execute 'nnoremap <silent> [Tag]'.n  ':<C-u>tabnext'.n.'<CR>'
endfor
" t1 で1番左のタブ、t2 で1番左から2番目のタブにジャンプ

map <silent> [Tag]c :tablast <bar> tabnew<CR>
" tc 新しいタブを一番右に作る
map <silent> [Tag]x :tabclose<CR>
" tx タブを閉じる
map <silent> [Tag]n :tabnext<CR>
" tn 次のタブ
map <silent> [Tag]p :tabprevious<CR>
" tp 前のタブ
